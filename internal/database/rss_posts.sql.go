// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: rss_posts.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createRSSFavoritePost = `-- name: CreateRSSFavoritePost :one
INSERT INTO postfavorites (post_id, feed_id, user_id, created_at)
VALUES ($1, $2, $3, $4)
RETURNING id, post_id, feed_id, user_id, created_at
`

type CreateRSSFavoritePostParams struct {
	PostID    uuid.UUID
	FeedID    uuid.UUID
	UserID    int64
	CreatedAt time.Time
}

func (q *Queries) CreateRSSFavoritePost(ctx context.Context, arg CreateRSSFavoritePostParams) (Postfavorite, error) {
	row := q.db.QueryRowContext(ctx, createRSSFavoritePost,
		arg.PostID,
		arg.FeedID,
		arg.UserID,
		arg.CreatedAt,
	)
	var i Postfavorite
	err := row.Scan(
		&i.ID,
		&i.PostID,
		&i.FeedID,
		&i.UserID,
		&i.CreatedAt,
	)
	return i, err
}

const createRssFeedPost = `-- name: CreateRssFeedPost :one



INSERT INTO rssfeed_posts (
    id, 
    created_at, 
    updated_at, 
    channeltitle, 
    channelurl,
    channeldescription,
    channellanguage,
    itemtitle,
    itemdescription, 
    itempublished_at, 
    itemcontent,
    itemurl, 
    img_url, 
    feed_id
)
VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9, $10, $11, $12, $13, $14)
RETURNING id, created_at, updated_at, channeltitle, channelurl, channeldescription, channellanguage, itemtitle, itemdescription, itempublished_at, itemurl, img_url, feed_id, itemcontent
`

type CreateRssFeedPostParams struct {
	ID                 uuid.UUID
	CreatedAt          time.Time
	UpdatedAt          time.Time
	Channeltitle       string
	Channelurl         sql.NullString
	Channeldescription sql.NullString
	Channellanguage    sql.NullString
	Itemtitle          string
	Itemdescription    sql.NullString
	ItempublishedAt    time.Time
	Itemcontent        sql.NullString
	Itemurl            string
	ImgUrl             string
	FeedID             uuid.UUID
}

// Parameter 2: post_id
func (q *Queries) CreateRssFeedPost(ctx context.Context, arg CreateRssFeedPostParams) (RssfeedPost, error) {
	row := q.db.QueryRowContext(ctx, createRssFeedPost,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Channeltitle,
		arg.Channelurl,
		arg.Channeldescription,
		arg.Channellanguage,
		arg.Itemtitle,
		arg.Itemdescription,
		arg.ItempublishedAt,
		arg.Itemcontent,
		arg.Itemurl,
		arg.ImgUrl,
		arg.FeedID,
	)
	var i RssfeedPost
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Channeltitle,
		&i.Channelurl,
		&i.Channeldescription,
		&i.Channellanguage,
		&i.Itemtitle,
		&i.Itemdescription,
		&i.ItempublishedAt,
		&i.Itemurl,
		&i.ImgUrl,
		&i.FeedID,
		&i.Itemcontent,
	)
	return i, err
}

const deleteRSSFavoritePost = `-- name: DeleteRSSFavoritePost :exec
DELETE FROM postfavorites
WHERE post_id = $1 AND user_id = $2
`

type DeleteRSSFavoritePostParams struct {
	PostID uuid.UUID
	UserID int64
}

func (q *Queries) DeleteRSSFavoritePost(ctx context.Context, arg DeleteRSSFavoritePostParams) error {
	_, err := q.db.ExecContext(ctx, deleteRSSFavoritePost, arg.PostID, arg.UserID)
	return err
}

const getFollowedRssPostsForUser = `-- name: GetFollowedRssPostsForUser :many
SELECT 
    p.id, p.created_at, p.updated_at, p.channeltitle, p.channelurl, p.channeldescription, p.channellanguage, p.itemtitle, p.itemdescription, p.itempublished_at, p.itemurl, p.img_url, p.feed_id, p.itemcontent, 
    COALESCE(pf.is_favorite, false) AS is_favorite,
    COUNT(*) OVER() AS total_count
FROM 
    rssfeed_posts p
JOIN (
    SELECT 
        ff.feed_id 
    FROM 
        feed_follows ff
    WHERE 
        ff.user_id = $1  -- Parameter 1: user_id
) ff ON p.feed_id = ff.feed_id
LEFT JOIN (
    SELECT 
        pf.post_id,
        true AS is_favorite
    FROM 
        postfavorites pf
    WHERE 
        pf.user_id = $1  -- Parameter 1: user_id
) pf ON p.id = pf.post_id
WHERE 
    ($2 = '' OR to_tsvector('simple', p.itemtitle) @@ plainto_tsquery('simple', $2))  -- Parameter 2: itemtitle (full-text search for item title)
    AND ($3::uuid = '00000000-0000-0000-0000-000000000000' OR p.feed_id = $3::uuid)  -- Parameter 3: feed_id (filter by feed_id if provided)
ORDER BY 
    p.created_at DESC
LIMIT $4 OFFSET $5
`

type GetFollowedRssPostsForUserParams struct {
	UserID  int64
	Column2 interface{}
	Column3 uuid.UUID
	Limit   int32
	Offset  int32
}

type GetFollowedRssPostsForUserRow struct {
	ID                 uuid.UUID
	CreatedAt          time.Time
	UpdatedAt          time.Time
	Channeltitle       string
	Channelurl         sql.NullString
	Channeldescription sql.NullString
	Channellanguage    sql.NullString
	Itemtitle          string
	Itemdescription    sql.NullString
	ItempublishedAt    time.Time
	Itemurl            string
	ImgUrl             string
	FeedID             uuid.UUID
	Itemcontent        sql.NullString
	IsFavorite         bool
	TotalCount         int64
}

func (q *Queries) GetFollowedRssPostsForUser(ctx context.Context, arg GetFollowedRssPostsForUserParams) ([]GetFollowedRssPostsForUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getFollowedRssPostsForUser,
		arg.UserID,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFollowedRssPostsForUserRow
	for rows.Next() {
		var i GetFollowedRssPostsForUserRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Channeltitle,
			&i.Channelurl,
			&i.Channeldescription,
			&i.Channellanguage,
			&i.Itemtitle,
			&i.Itemdescription,
			&i.ItempublishedAt,
			&i.Itemurl,
			&i.ImgUrl,
			&i.FeedID,
			&i.Itemcontent,
			&i.IsFavorite,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRSSFavoritePostsForUser = `-- name: GetRSSFavoritePostsForUser :many


SELECT id, post_id, feed_id, user_id, created_at
FROM postfavorites
WHERE user_id = $1
`

// Parameters 4 and 5: limit and offset
func (q *Queries) GetRSSFavoritePostsForUser(ctx context.Context, userID int64) ([]Postfavorite, error) {
	rows, err := q.db.QueryContext(ctx, getRSSFavoritePostsForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Postfavorite
	for rows.Next() {
		var i Postfavorite
		if err := rows.Scan(
			&i.ID,
			&i.PostID,
			&i.FeedID,
			&i.UserID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRSSFavoritePostsOnlyForUser = `-- name: GetRSSFavoritePostsOnlyForUser :many
SELECT 
    COUNT(*) OVER() AS total_count,
    p.id,
    p.created_at,
    p.updated_at,
    p.channeltitle,
    p.channelurl,
    p.channeldescription,
    p.channellanguage,
    p.itemtitle,
    p.itemdescription,
    p.itemcontent,
    p.itempublished_at,
    p.itemurl,
    p.img_url,
    p.feed_id,
    true AS is_favorite,  -- Initialize is_favorite to true
    COALESCE(ff.user_id IS NOT NULL, false) AS is_followed_feed  -- Determine if the feed is followed
FROM 
    rssfeed_posts p
JOIN 
    postfavorites f ON p.id = f.post_id
LEFT JOIN
    feed_follows ff ON p.feed_id = ff.feed_id AND ff.user_id = $1  -- Check if the user follows the feed
WHERE 
    f.user_id = $1  -- Parameter 1: user_id
    AND ($2 = '' OR to_tsvector('simple', p.itemtitle) @@ plainto_tsquery('simple', $2))  -- Parameter 2: itemtitle (full-text search for item title)
    AND ($3::uuid = '00000000-0000-0000-0000-000000000000' OR p.feed_id = $3::uuid)  -- Parameter 3: feed_id (filter by feed_id if provided)
ORDER BY 
    p.created_at DESC
LIMIT $4 OFFSET $5
`

type GetRSSFavoritePostsOnlyForUserParams struct {
	UserID  int64
	Column2 interface{}
	Column3 uuid.UUID
	Limit   int32
	Offset  int32
}

type GetRSSFavoritePostsOnlyForUserRow struct {
	TotalCount         int64
	ID                 uuid.UUID
	CreatedAt          time.Time
	UpdatedAt          time.Time
	Channeltitle       string
	Channelurl         sql.NullString
	Channeldescription sql.NullString
	Channellanguage    sql.NullString
	Itemtitle          string
	Itemdescription    sql.NullString
	Itemcontent        sql.NullString
	ItempublishedAt    time.Time
	Itemurl            string
	ImgUrl             string
	FeedID             uuid.UUID
	IsFavorite         bool
	IsFollowedFeed     interface{}
}

func (q *Queries) GetRSSFavoritePostsOnlyForUser(ctx context.Context, arg GetRSSFavoritePostsOnlyForUserParams) ([]GetRSSFavoritePostsOnlyForUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getRSSFavoritePostsOnlyForUser,
		arg.UserID,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRSSFavoritePostsOnlyForUserRow
	for rows.Next() {
		var i GetRSSFavoritePostsOnlyForUserRow
		if err := rows.Scan(
			&i.TotalCount,
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Channeltitle,
			&i.Channelurl,
			&i.Channeldescription,
			&i.Channellanguage,
			&i.Itemtitle,
			&i.Itemdescription,
			&i.Itemcontent,
			&i.ItempublishedAt,
			&i.Itemurl,
			&i.ImgUrl,
			&i.FeedID,
			&i.IsFavorite,
			&i.IsFollowedFeed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRandomRSSPosts = `-- name: GetRandomRSSPosts :many
SELECT id, created_at, updated_at, channeltitle, channelurl, channeldescription, channellanguage, itemtitle, itemdescription, itempublished_at, itemurl, img_url, feed_id, itemcontent
FROM rssfeed_posts
WHERE feed_id = $1
ORDER BY RANDOM()
LIMIT $2 OFFSET $3
`

type GetRandomRSSPostsParams struct {
	FeedID uuid.UUID
	Limit  int32
	Offset int32
}

func (q *Queries) GetRandomRSSPosts(ctx context.Context, arg GetRandomRSSPostsParams) ([]RssfeedPost, error) {
	rows, err := q.db.QueryContext(ctx, getRandomRSSPosts, arg.FeedID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RssfeedPost
	for rows.Next() {
		var i RssfeedPost
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Channeltitle,
			&i.Channelurl,
			&i.Channeldescription,
			&i.Channellanguage,
			&i.Itemtitle,
			&i.Itemdescription,
			&i.ItempublishedAt,
			&i.Itemurl,
			&i.ImgUrl,
			&i.FeedID,
			&i.Itemcontent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRssPostByPostID = `-- name: GetRssPostByPostID :one
SELECT 
    p.id,
    p.created_at,
    p.updated_at,
    p.channeltitle,
    p.channelurl,
    p.channeldescription,
    p.channellanguage,
    p.itemtitle,
    p.itemdescription,
    p.itemcontent,
    p.itempublished_at,
    p.itemurl,
    p.img_url,
    p.feed_id,
    COALESCE(f.user_id IS NOT NULL, false) AS is_favorite,
    COALESCE(ff.user_id IS NOT NULL, false) AS is_followed_feed
FROM 
    rssfeed_posts p
LEFT JOIN 
    postfavorites f ON p.id = f.post_id AND f.user_id = $1
LEFT JOIN
    feed_follows ff ON p.feed_id = ff.feed_id AND ff.user_id = $1
WHERE 
    p.id = $2::uuid
`

type GetRssPostByPostIDParams struct {
	UserID  int64
	Column2 uuid.UUID
}

type GetRssPostByPostIDRow struct {
	ID                 uuid.UUID
	CreatedAt          time.Time
	UpdatedAt          time.Time
	Channeltitle       string
	Channelurl         sql.NullString
	Channeldescription sql.NullString
	Channellanguage    sql.NullString
	Itemtitle          string
	Itemdescription    sql.NullString
	Itemcontent        sql.NullString
	ItempublishedAt    time.Time
	Itemurl            string
	ImgUrl             string
	FeedID             uuid.UUID
	IsFavorite         interface{}
	IsFollowedFeed     interface{}
}

func (q *Queries) GetRssPostByPostID(ctx context.Context, arg GetRssPostByPostIDParams) (GetRssPostByPostIDRow, error) {
	row := q.db.QueryRowContext(ctx, getRssPostByPostID, arg.UserID, arg.Column2)
	var i GetRssPostByPostIDRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Channeltitle,
		&i.Channelurl,
		&i.Channeldescription,
		&i.Channellanguage,
		&i.Itemtitle,
		&i.Itemdescription,
		&i.Itemcontent,
		&i.ItempublishedAt,
		&i.Itemurl,
		&i.ImgUrl,
		&i.FeedID,
		&i.IsFavorite,
		&i.IsFollowedFeed,
	)
	return i, err
}
