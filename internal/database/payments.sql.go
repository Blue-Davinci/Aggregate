// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: payments.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createSubscription = `-- name: CreateSubscription :one
INSERT INTO subscriptions (
		user_id, plan_id, start_date, end_date, price, status, 
		transaction_id, payment_method, authorization_code, 
		card_last4, card_exp_month, card_exp_year, card_type, currency
) VALUES (
	$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
)
RETURNING id, created_at, updated_at
`

type CreateSubscriptionParams struct {
	UserID            int64
	PlanID            int32
	StartDate         time.Time
	EndDate           time.Time
	Price             string
	Status            string
	TransactionID     int64
	PaymentMethod     sql.NullString
	AuthorizationCode sql.NullString
	CardLast4         sql.NullString
	CardExpMonth      sql.NullString
	CardExpYear       sql.NullString
	CardType          sql.NullString
	Currency          sql.NullString
}

type CreateSubscriptionRow struct {
	ID        uuid.UUID
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) (CreateSubscriptionRow, error) {
	row := q.db.QueryRowContext(ctx, createSubscription,
		arg.UserID,
		arg.PlanID,
		arg.StartDate,
		arg.EndDate,
		arg.Price,
		arg.Status,
		arg.TransactionID,
		arg.PaymentMethod,
		arg.AuthorizationCode,
		arg.CardLast4,
		arg.CardExpMonth,
		arg.CardExpYear,
		arg.CardType,
		arg.Currency,
	)
	var i CreateSubscriptionRow
	err := row.Scan(&i.ID, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const getAllSubscriptionsByID = `-- name: GetAllSubscriptionsByID :many
SELECT 
    count(*) OVER() as total_records,
    s.id, 
    s.user_id, 
    s.plan_id, 
    p.name as plan_name,
    p.image as plan_image,
    p.duration as plan_duration,
    s.start_date, 
    s.end_date, 
    s.price, 
    s.status, 
    s.transaction_id, 
    s.payment_method, 
    s.card_last4, 
    s.card_exp_month, 
    s.card_exp_year, 
    s.card_type, 
    s.currency, 
    s.created_at, 
    s.updated_at
FROM 
    subscriptions s
JOIN 
    payment_plans p ON s.plan_id = p.id
WHERE 
    s.user_id = $1 
ORDER BY 
    s.start_date DESC
LIMIT $2 OFFSET $3
`

type GetAllSubscriptionsByIDParams struct {
	UserID int64
	Limit  int32
	Offset int32
}

type GetAllSubscriptionsByIDRow struct {
	TotalRecords  int64
	ID            uuid.UUID
	UserID        int64
	PlanID        int32
	PlanName      string
	PlanImage     string
	PlanDuration  string
	StartDate     time.Time
	EndDate       time.Time
	Price         string
	Status        string
	TransactionID int64
	PaymentMethod sql.NullString
	CardLast4     sql.NullString
	CardExpMonth  sql.NullString
	CardExpYear   sql.NullString
	CardType      sql.NullString
	Currency      sql.NullString
	CreatedAt     time.Time
	UpdatedAt     time.Time
}

func (q *Queries) GetAllSubscriptionsByID(ctx context.Context, arg GetAllSubscriptionsByIDParams) ([]GetAllSubscriptionsByIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllSubscriptionsByID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllSubscriptionsByIDRow
	for rows.Next() {
		var i GetAllSubscriptionsByIDRow
		if err := rows.Scan(
			&i.TotalRecords,
			&i.ID,
			&i.UserID,
			&i.PlanID,
			&i.PlanName,
			&i.PlanImage,
			&i.PlanDuration,
			&i.StartDate,
			&i.EndDate,
			&i.Price,
			&i.Status,
			&i.TransactionID,
			&i.PaymentMethod,
			&i.CardLast4,
			&i.CardExpMonth,
			&i.CardExpYear,
			&i.CardType,
			&i.Currency,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentPlanByID = `-- name: GetPaymentPlanByID :one
SELECT id, name, image, description, duration, price, features, created_at, updated_at, status
FROM payment_plans
WHERE id = $1 AND status = 'active'
`

func (q *Queries) GetPaymentPlanByID(ctx context.Context, id int32) (PaymentPlan, error) {
	row := q.db.QueryRowContext(ctx, getPaymentPlanByID, id)
	var i PaymentPlan
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Image,
		&i.Description,
		&i.Duration,
		&i.Price,
		pq.Array(&i.Features),
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
	)
	return i, err
}

const getPaymentPlans = `-- name: GetPaymentPlans :many
SELECT id, name, image, description, duration, price, features, created_at, updated_at, status
FROM payment_plans
WHERE status = 'active'
`

func (q *Queries) GetPaymentPlans(ctx context.Context) ([]PaymentPlan, error) {
	rows, err := q.db.QueryContext(ctx, getPaymentPlans)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentPlan
	for rows.Next() {
		var i PaymentPlan
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Image,
			&i.Description,
			&i.Duration,
			&i.Price,
			pq.Array(&i.Features),
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscriptionByID = `-- name: GetSubscriptionByID :one
SELECT id, user_id, plan_id, start_date, end_date, price, status
FROM subscriptions
WHERE user_id = $1 AND status = 'active' AND end_date > NOW()
`

type GetSubscriptionByIDRow struct {
	ID        uuid.UUID
	UserID    int64
	PlanID    int32
	StartDate time.Time
	EndDate   time.Time
	Price     string
	Status    string
}

func (q *Queries) GetSubscriptionByID(ctx context.Context, userID int64) (GetSubscriptionByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getSubscriptionByID, userID)
	var i GetSubscriptionByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PlanID,
		&i.StartDate,
		&i.EndDate,
		&i.Price,
		&i.Status,
	)
	return i, err
}
