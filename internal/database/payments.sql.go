// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: payments.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createChallangedTransaction = `-- name: CreateChallangedTransaction :one
INSERT INTO challenged_transactions (
    user_id,
    referenced_subscription_id,
    authorization_url,
    reference,
    status
) VALUES ($1,$2,$3, $4, $5) 
RETURNING id, created_at
`

type CreateChallangedTransactionParams struct {
	UserID                   int64
	ReferencedSubscriptionID uuid.UUID
	AuthorizationUrl         string
	Reference                string
	Status                   string
}

type CreateChallangedTransactionRow struct {
	ID        int64
	CreatedAt time.Time
}

func (q *Queries) CreateChallangedTransaction(ctx context.Context, arg CreateChallangedTransactionParams) (CreateChallangedTransactionRow, error) {
	row := q.db.QueryRowContext(ctx, createChallangedTransaction,
		arg.UserID,
		arg.ReferencedSubscriptionID,
		arg.AuthorizationUrl,
		arg.Reference,
		arg.Status,
	)
	var i CreateChallangedTransactionRow
	err := row.Scan(&i.ID, &i.CreatedAt)
	return i, err
}

const createFailedTransaction = `-- name: CreateFailedTransaction :one
INSERT INTO failed_transactions (
    user_id, 
    subscription_id, 
    attempt_date, 
    authorization_code, 
    reference, 
    amount, 
    failure_reason, 
    error_code, 
    card_last4, 
    card_exp_month, 
    card_exp_year, 
    card_type
) VALUES ($1, $2, NOW(), $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, created_at, updated_at
`

type CreateFailedTransactionParams struct {
	UserID            int64
	SubscriptionID    uuid.UUID
	AuthorizationCode sql.NullString
	Reference         string
	Amount            string
	FailureReason     sql.NullString
	ErrorCode         sql.NullString
	CardLast4         sql.NullString
	CardExpMonth      sql.NullString
	CardExpYear       sql.NullString
	CardType          sql.NullString
}

type CreateFailedTransactionRow struct {
	ID        int64
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) CreateFailedTransaction(ctx context.Context, arg CreateFailedTransactionParams) (CreateFailedTransactionRow, error) {
	row := q.db.QueryRowContext(ctx, createFailedTransaction,
		arg.UserID,
		arg.SubscriptionID,
		arg.AuthorizationCode,
		arg.Reference,
		arg.Amount,
		arg.FailureReason,
		arg.ErrorCode,
		arg.CardLast4,
		arg.CardExpMonth,
		arg.CardExpYear,
		arg.CardType,
	)
	var i CreateFailedTransactionRow
	err := row.Scan(&i.ID, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const createSubscription = `-- name: CreateSubscription :one
INSERT INTO subscriptions (
		user_id, plan_id, start_date, end_date, price, status, 
		transaction_id, payment_method, authorization_code, 
		card_last4, card_exp_month, card_exp_year, card_type, currency
) VALUES (
	$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14
)
RETURNING id, created_at, updated_at
`

type CreateSubscriptionParams struct {
	UserID            int64
	PlanID            int32
	StartDate         time.Time
	EndDate           time.Time
	Price             string
	Status            string
	TransactionID     int64
	PaymentMethod     sql.NullString
	AuthorizationCode sql.NullString
	CardLast4         sql.NullString
	CardExpMonth      sql.NullString
	CardExpYear       sql.NullString
	CardType          sql.NullString
	Currency          sql.NullString
}

type CreateSubscriptionRow struct {
	ID        uuid.UUID
	CreatedAt time.Time
	UpdatedAt time.Time
}

func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) (CreateSubscriptionRow, error) {
	row := q.db.QueryRowContext(ctx, createSubscription,
		arg.UserID,
		arg.PlanID,
		arg.StartDate,
		arg.EndDate,
		arg.Price,
		arg.Status,
		arg.TransactionID,
		arg.PaymentMethod,
		arg.AuthorizationCode,
		arg.CardLast4,
		arg.CardExpMonth,
		arg.CardExpYear,
		arg.CardType,
		arg.Currency,
	)
	var i CreateSubscriptionRow
	err := row.Scan(&i.ID, &i.CreatedAt, &i.UpdatedAt)
	return i, err
}

const getActiveOrNonExpiredSubscriptionByID = `-- name: GetActiveOrNonExpiredSubscriptionByID :one
SELECT 
    s.id, 
    s.user_id, 
    s.plan_id, 
    p.name as plan_name,
    p.image as plan_image,
    p.duration as plan_duration,
    s.start_date, 
    s.end_date, 
    s.price, 
    s.status, 
    s.transaction_id, 
    s.payment_method, 
    s.card_last4, 
    s.card_exp_month, 
    s.card_exp_year, 
    s.card_type, 
    s.currency, 
    s.created_at, 
    s.updated_at
FROM 
    subscriptions s
JOIN 
    payment_plans p ON s.plan_id = p.id
WHERE 
    s.user_id = $1
    AND s.status IN ('active', 'cancelled')
    AND (s.status != 'cancelled' OR s.end_date > now())  -- Only include 'cancelled' if end_date is in the future
ORDER BY 
    s.start_date DESC
LIMIT 1
`

type GetActiveOrNonExpiredSubscriptionByIDRow struct {
	ID            uuid.UUID
	UserID        int64
	PlanID        int32
	PlanName      string
	PlanImage     string
	PlanDuration  string
	StartDate     time.Time
	EndDate       time.Time
	Price         string
	Status        string
	TransactionID int64
	PaymentMethod sql.NullString
	CardLast4     sql.NullString
	CardExpMonth  sql.NullString
	CardExpYear   sql.NullString
	CardType      sql.NullString
	Currency      sql.NullString
	CreatedAt     time.Time
	UpdatedAt     time.Time
}

func (q *Queries) GetActiveOrNonExpiredSubscriptionByID(ctx context.Context, userID int64) (GetActiveOrNonExpiredSubscriptionByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getActiveOrNonExpiredSubscriptionByID, userID)
	var i GetActiveOrNonExpiredSubscriptionByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PlanID,
		&i.PlanName,
		&i.PlanImage,
		&i.PlanDuration,
		&i.StartDate,
		&i.EndDate,
		&i.Price,
		&i.Status,
		&i.TransactionID,
		&i.PaymentMethod,
		&i.CardLast4,
		&i.CardExpMonth,
		&i.CardExpYear,
		&i.CardType,
		&i.Currency,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAllExpiredSubscriptions = `-- name: GetAllExpiredSubscriptions :many
SELECT count(*) OVER() as total_records,
    s.id AS subscription_id,
    s.authorization_code,
    s.plan_id,
    s.price,
    s.currency,
    s.user_id,
    u.email,
    u.name
FROM 
    subscriptions s
JOIN 
    users u ON s.user_id = u.id
WHERE 
    s.status = 'expired' AND s.end_date < NOW()
ORDER BY 
    s.end_date ASC
LIMIT $1 OFFSET $2
`

type GetAllExpiredSubscriptionsParams struct {
	Limit  int32
	Offset int32
}

type GetAllExpiredSubscriptionsRow struct {
	TotalRecords      int64
	SubscriptionID    uuid.UUID
	AuthorizationCode sql.NullString
	PlanID            int32
	Price             string
	Currency          sql.NullString
	UserID            int64
	Email             string
	Name              string
}

func (q *Queries) GetAllExpiredSubscriptions(ctx context.Context, arg GetAllExpiredSubscriptionsParams) ([]GetAllExpiredSubscriptionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllExpiredSubscriptions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllExpiredSubscriptionsRow
	for rows.Next() {
		var i GetAllExpiredSubscriptionsRow
		if err := rows.Scan(
			&i.TotalRecords,
			&i.SubscriptionID,
			&i.AuthorizationCode,
			&i.PlanID,
			&i.Price,
			&i.Currency,
			&i.UserID,
			&i.Email,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSubscriptionsByID = `-- name: GetAllSubscriptionsByID :many
SELECT 
    count(*) OVER() as total_records,
    s.id, 
    s.user_id, 
    s.plan_id, 
    p.name as plan_name,
    p.image as plan_image,
    p.duration as plan_duration,
    s.start_date, 
    s.end_date, 
    s.price, 
    s.status, 
    s.transaction_id, 
    s.payment_method, 
    s.card_last4, 
    s.card_exp_month, 
    s.card_exp_year, 
    s.card_type, 
    s.currency, 
    s.created_at, 
    s.updated_at
FROM 
    subscriptions s
JOIN 
    payment_plans p ON s.plan_id = p.id
WHERE 
    s.user_id = $1 
ORDER BY 
    s.start_date DESC
LIMIT $2 OFFSET $3
`

type GetAllSubscriptionsByIDParams struct {
	UserID int64
	Limit  int32
	Offset int32
}

type GetAllSubscriptionsByIDRow struct {
	TotalRecords  int64
	ID            uuid.UUID
	UserID        int64
	PlanID        int32
	PlanName      string
	PlanImage     string
	PlanDuration  string
	StartDate     time.Time
	EndDate       time.Time
	Price         string
	Status        string
	TransactionID int64
	PaymentMethod sql.NullString
	CardLast4     sql.NullString
	CardExpMonth  sql.NullString
	CardExpYear   sql.NullString
	CardType      sql.NullString
	Currency      sql.NullString
	CreatedAt     time.Time
	UpdatedAt     time.Time
}

func (q *Queries) GetAllSubscriptionsByID(ctx context.Context, arg GetAllSubscriptionsByIDParams) ([]GetAllSubscriptionsByIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllSubscriptionsByID, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllSubscriptionsByIDRow
	for rows.Next() {
		var i GetAllSubscriptionsByIDRow
		if err := rows.Scan(
			&i.TotalRecords,
			&i.ID,
			&i.UserID,
			&i.PlanID,
			&i.PlanName,
			&i.PlanImage,
			&i.PlanDuration,
			&i.StartDate,
			&i.EndDate,
			&i.Price,
			&i.Status,
			&i.TransactionID,
			&i.PaymentMethod,
			&i.CardLast4,
			&i.CardExpMonth,
			&i.CardExpYear,
			&i.CardType,
			&i.Currency,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPaymentPlanByID = `-- name: GetPaymentPlanByID :one
SELECT id, name, image, description, duration, price, features, created_at, updated_at, status
FROM payment_plans
WHERE id = $1 AND status = 'active'
`

func (q *Queries) GetPaymentPlanByID(ctx context.Context, id int32) (PaymentPlan, error) {
	row := q.db.QueryRowContext(ctx, getPaymentPlanByID, id)
	var i PaymentPlan
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Image,
		&i.Description,
		&i.Duration,
		&i.Price,
		pq.Array(&i.Features),
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
	)
	return i, err
}

const getPaymentPlans = `-- name: GetPaymentPlans :many
SELECT id, name, image, description, duration, price, features, created_at, updated_at, status
FROM payment_plans
WHERE status = 'active'
`

func (q *Queries) GetPaymentPlans(ctx context.Context) ([]PaymentPlan, error) {
	rows, err := q.db.QueryContext(ctx, getPaymentPlans)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PaymentPlan
	for rows.Next() {
		var i PaymentPlan
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Image,
			&i.Description,
			&i.Duration,
			&i.Price,
			pq.Array(&i.Features),
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingChallengedTransactionByReference = `-- name: GetPendingChallengedTransactionByReference :one
SELECT 
    id, 
    user_id, 
    referenced_subscription_id, 
    authorization_url, 
    reference, 
    created_at, 
    updated_at, 
    status
FROM 
    challenged_transactions
WHERE 
    reference = $1
    AND status = 'pending'
`

func (q *Queries) GetPendingChallengedTransactionByReference(ctx context.Context, reference string) (ChallengedTransaction, error) {
	row := q.db.QueryRowContext(ctx, getPendingChallengedTransactionByReference, reference)
	var i ChallengedTransaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ReferencedSubscriptionID,
		&i.AuthorizationUrl,
		&i.Reference,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
	)
	return i, err
}

const getPendingChallengedTransactionBySubscriptionID = `-- name: GetPendingChallengedTransactionBySubscriptionID :one
SELECT 
    id, 
    user_id, 
    referenced_subscription_id, 
    authorization_url, 
    reference, 
    created_at, 
    updated_at, 
    status
FROM 
    challenged_transactions
WHERE 
    referenced_subscription_id = $1
    AND status = 'pending'
`

func (q *Queries) GetPendingChallengedTransactionBySubscriptionID(ctx context.Context, referencedSubscriptionID uuid.UUID) (ChallengedTransaction, error) {
	row := q.db.QueryRowContext(ctx, getPendingChallengedTransactionBySubscriptionID, referencedSubscriptionID)
	var i ChallengedTransaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ReferencedSubscriptionID,
		&i.AuthorizationUrl,
		&i.Reference,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
	)
	return i, err
}

const getPendingChallengedTransactionsByUser = `-- name: GetPendingChallengedTransactionsByUser :many
SELECT 
    id,
    user_id,
    referenced_subscription_id,
    authorization_url,
    reference,
    created_at,
    updated_at,
    status
FROM 
    challenged_transactions
WHERE 
    user_id = $1
    AND status = 'pending'
`

func (q *Queries) GetPendingChallengedTransactionsByUser(ctx context.Context, userID int64) ([]ChallengedTransaction, error) {
	rows, err := q.db.QueryContext(ctx, getPendingChallengedTransactionsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChallengedTransaction
	for rows.Next() {
		var i ChallengedTransaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.ReferencedSubscriptionID,
			&i.AuthorizationUrl,
			&i.Reference,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscriptionByID = `-- name: GetSubscriptionByID :one
SELECT id, user_id, plan_id, start_date, end_date, price, status
FROM subscriptions
WHERE user_id = $1 AND status = 'active' AND end_date > NOW()
`

type GetSubscriptionByIDRow struct {
	ID        uuid.UUID
	UserID    int64
	PlanID    int32
	StartDate time.Time
	EndDate   time.Time
	Price     string
	Status    string
}

func (q *Queries) GetSubscriptionByID(ctx context.Context, userID int64) (GetSubscriptionByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getSubscriptionByID, userID)
	var i GetSubscriptionByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PlanID,
		&i.StartDate,
		&i.EndDate,
		&i.Price,
		&i.Status,
	)
	return i, err
}

const updateChallengedTransactionStatus = `-- name: UpdateChallengedTransactionStatus :one
UPDATE challenged_transactions
SET status = $1, updated_at = NOW()
WHERE id = $2
AND user_id = $3
RETURNING id, user_id, referenced_subscription_id, authorization_url, reference, created_at, updated_at, status
`

type UpdateChallengedTransactionStatusParams struct {
	Status string
	ID     int64
	UserID int64
}

func (q *Queries) UpdateChallengedTransactionStatus(ctx context.Context, arg UpdateChallengedTransactionStatusParams) (ChallengedTransaction, error) {
	row := q.db.QueryRowContext(ctx, updateChallengedTransactionStatus, arg.Status, arg.ID, arg.UserID)
	var i ChallengedTransaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ReferencedSubscriptionID,
		&i.AuthorizationUrl,
		&i.Reference,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Status,
	)
	return i, err
}

const updateExpiredChallengedTransactionStatus = `-- name: UpdateExpiredChallengedTransactionStatus :many
UPDATE challenged_transactions
SET status = 'failed', updated_at = NOW()
WHERE status = 'pending'
AND created_at < NOW() - INTERVAL '24 hours'
RETURNING id, user_id, updated_at
`

type UpdateExpiredChallengedTransactionStatusRow struct {
	ID        int64
	UserID    int64
	UpdatedAt time.Time
}

func (q *Queries) UpdateExpiredChallengedTransactionStatus(ctx context.Context) ([]UpdateExpiredChallengedTransactionStatusRow, error) {
	rows, err := q.db.QueryContext(ctx, updateExpiredChallengedTransactionStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UpdateExpiredChallengedTransactionStatusRow
	for rows.Next() {
		var i UpdateExpiredChallengedTransactionStatusRow
		if err := rows.Scan(&i.ID, &i.UserID, &i.UpdatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSubscriptionStatus = `-- name: UpdateSubscriptionStatus :one
UPDATE subscriptions
SET status = $1, updated_at = NOW()
WHERE id = $2
AND user_id = $3
RETURNING updated_at
`

type UpdateSubscriptionStatusParams struct {
	Status string
	ID     uuid.UUID
	UserID int64
}

func (q *Queries) UpdateSubscriptionStatus(ctx context.Context, arg UpdateSubscriptionStatusParams) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, updateSubscriptionStatus, arg.Status, arg.ID, arg.UserID)
	var updated_at time.Time
	err := row.Scan(&updated_at)
	return updated_at, err
}

const updateSubscriptionStatusAfterExpiration = `-- name: UpdateSubscriptionStatusAfterExpiration :many
UPDATE subscriptions
SET status = 'expired', updated_at = NOW()
WHERE end_date < CURRENT_DATE
AND status NOT IN ('expired', 'renewed', 'cancelled')
RETURNING id, user_id, updated_at
`

type UpdateSubscriptionStatusAfterExpirationRow struct {
	ID        uuid.UUID
	UserID    int64
	UpdatedAt time.Time
}

func (q *Queries) UpdateSubscriptionStatusAfterExpiration(ctx context.Context) ([]UpdateSubscriptionStatusAfterExpirationRow, error) {
	rows, err := q.db.QueryContext(ctx, updateSubscriptionStatusAfterExpiration)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UpdateSubscriptionStatusAfterExpirationRow
	for rows.Next() {
		var i UpdateSubscriptionStatusAfterExpirationRow
		if err := rows.Scan(&i.ID, &i.UserID, &i.UpdatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
